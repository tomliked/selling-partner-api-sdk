/*
 * Selling Partner API for Retail Procurement Orders
 * The Selling Partner API for Retail Procurement Orders provides programmatic access to vendor orders data.
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package software.amazon.spapi.models.vendor.orders.v1;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * Import details for an import order.
 */
@Schema(description = "Import details for an import order.")


public class ImportDetails {
  /**
   * If the recipient requests, contains the shipment method of payment. This is for import PO&#x27;s only.
   */
  @JsonAdapter(MethodOfPaymentEnum.Adapter.class)
  public enum MethodOfPaymentEnum {
    @SerializedName("PaidByBuyer")
    PAIDBYBUYER("PaidByBuyer"),
    @SerializedName("CollectOnDelivery")
    COLLECTONDELIVERY("CollectOnDelivery"),
    @SerializedName("DefinedByBuyerAndSeller")
    DEFINEDBYBUYERANDSELLER("DefinedByBuyerAndSeller"),
    @SerializedName("FOBPortOfCall")
    FOBPORTOFCALL("FOBPortOfCall"),
    @SerializedName("PrepaidBySeller")
    PREPAIDBYSELLER("PrepaidBySeller"),
    @SerializedName("PaidBySeller")
    PAIDBYSELLER("PaidBySeller");

    private String value;

    MethodOfPaymentEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static MethodOfPaymentEnum fromValue(String input) {
      for (MethodOfPaymentEnum b : MethodOfPaymentEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<MethodOfPaymentEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MethodOfPaymentEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public MethodOfPaymentEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return MethodOfPaymentEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("methodOfPayment")
  private MethodOfPaymentEnum methodOfPayment = null;

  /**
   * Incoterms (International Commercial Terms) are used to divide transaction costs and responsibilities between buyer and seller and reflect state-of-the-art transportation practices. This is for import purchase orders only. 
   */
  @JsonAdapter(InternationalCommercialTermsEnum.Adapter.class)
  public enum InternationalCommercialTermsEnum {
    @SerializedName("ExWorks")
    EXWORKS("ExWorks"),
    @SerializedName("FreeCarrier")
    FREECARRIER("FreeCarrier"),
    @SerializedName("FreeOnBoard")
    FREEONBOARD("FreeOnBoard"),
    @SerializedName("FreeAlongSideShip")
    FREEALONGSIDESHIP("FreeAlongSideShip"),
    @SerializedName("CarriagePaidTo")
    CARRIAGEPAIDTO("CarriagePaidTo"),
    @SerializedName("CostAndFreight")
    COSTANDFREIGHT("CostAndFreight"),
    @SerializedName("CarriageAndInsurancePaidTo")
    CARRIAGEANDINSURANCEPAIDTO("CarriageAndInsurancePaidTo"),
    @SerializedName("CostInsuranceAndFreight")
    COSTINSURANCEANDFREIGHT("CostInsuranceAndFreight"),
    @SerializedName("DeliveredAtTerminal")
    DELIVEREDATTERMINAL("DeliveredAtTerminal"),
    @SerializedName("DeliveredAtPlace")
    DELIVEREDATPLACE("DeliveredAtPlace"),
    @SerializedName("DeliverDutyPaid")
    DELIVERDUTYPAID("DeliverDutyPaid");

    private String value;

    InternationalCommercialTermsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static InternationalCommercialTermsEnum fromValue(String input) {
      for (InternationalCommercialTermsEnum b : InternationalCommercialTermsEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<InternationalCommercialTermsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final InternationalCommercialTermsEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public InternationalCommercialTermsEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return InternationalCommercialTermsEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("internationalCommercialTerms")
  private InternationalCommercialTermsEnum internationalCommercialTerms = null;

  @SerializedName("portOfDelivery")
  private String portOfDelivery = null;

  @SerializedName("importContainers")
  private String importContainers = null;

  @SerializedName("shippingInstructions")
  private String shippingInstructions = null;

  public ImportDetails methodOfPayment(MethodOfPaymentEnum methodOfPayment) {
    this.methodOfPayment = methodOfPayment;
    return this;
  }

   /**
   * If the recipient requests, contains the shipment method of payment. This is for import PO&#x27;s only.
   * @return methodOfPayment
  **/
  @Schema(description = "If the recipient requests, contains the shipment method of payment. This is for import PO's only.")
  public MethodOfPaymentEnum getMethodOfPayment() {
    return methodOfPayment;
  }

  public void setMethodOfPayment(MethodOfPaymentEnum methodOfPayment) {
    this.methodOfPayment = methodOfPayment;
  }

  public ImportDetails internationalCommercialTerms(InternationalCommercialTermsEnum internationalCommercialTerms) {
    this.internationalCommercialTerms = internationalCommercialTerms;
    return this;
  }

   /**
   * Incoterms (International Commercial Terms) are used to divide transaction costs and responsibilities between buyer and seller and reflect state-of-the-art transportation practices. This is for import purchase orders only. 
   * @return internationalCommercialTerms
  **/
  @Schema(description = "Incoterms (International Commercial Terms) are used to divide transaction costs and responsibilities between buyer and seller and reflect state-of-the-art transportation practices. This is for import purchase orders only. ")
  public InternationalCommercialTermsEnum getInternationalCommercialTerms() {
    return internationalCommercialTerms;
  }

  public void setInternationalCommercialTerms(InternationalCommercialTermsEnum internationalCommercialTerms) {
    this.internationalCommercialTerms = internationalCommercialTerms;
  }

  public ImportDetails portOfDelivery(String portOfDelivery) {
    this.portOfDelivery = portOfDelivery;
    return this;
  }

   /**
   * The port where goods on an import purchase order must be delivered by the vendor. This should only be specified when the internationalCommercialTerms is FOB.
   * @return portOfDelivery
  **/
  @Schema(description = "The port where goods on an import purchase order must be delivered by the vendor. This should only be specified when the internationalCommercialTerms is FOB.")
  public String getPortOfDelivery() {
    return portOfDelivery;
  }

  public void setPortOfDelivery(String portOfDelivery) {
    this.portOfDelivery = portOfDelivery;
  }

  public ImportDetails importContainers(String importContainers) {
    this.importContainers = importContainers;
    return this;
  }

   /**
   * Types and numbers of container(s) for import purchase orders. Can be a comma-separated list if the shipment has multiple containers. HC signifies a high-capacity container. Free-text field, limited to 64 characters. The format will be a comma-delimited list containing values of the type: $NUMBER_OF_CONTAINERS_OF_THIS_TYPE-$CONTAINER_TYPE. The list of values for the container type is: 40&#x27;(40-foot container), 40&#x27;HC (40-foot high-capacity container), 45&#x27;, 45&#x27;HC, 30&#x27;, 30&#x27;HC, 20&#x27;, 20&#x27;HC.
   * @return importContainers
  **/
  @Schema(description = "Types and numbers of container(s) for import purchase orders. Can be a comma-separated list if the shipment has multiple containers. HC signifies a high-capacity container. Free-text field, limited to 64 characters. The format will be a comma-delimited list containing values of the type: $NUMBER_OF_CONTAINERS_OF_THIS_TYPE-$CONTAINER_TYPE. The list of values for the container type is: 40'(40-foot container), 40'HC (40-foot high-capacity container), 45', 45'HC, 30', 30'HC, 20', 20'HC.")
  public String getImportContainers() {
    return importContainers;
  }

  public void setImportContainers(String importContainers) {
    this.importContainers = importContainers;
  }

  public ImportDetails shippingInstructions(String shippingInstructions) {
    this.shippingInstructions = shippingInstructions;
    return this;
  }

   /**
   * Special instructions regarding the shipment. This field is for import purchase orders.
   * @return shippingInstructions
  **/
  @Schema(description = "Special instructions regarding the shipment. This field is for import purchase orders.")
  public String getShippingInstructions() {
    return shippingInstructions;
  }

  public void setShippingInstructions(String shippingInstructions) {
    this.shippingInstructions = shippingInstructions;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ImportDetails importDetails = (ImportDetails) o;
    return Objects.equals(this.methodOfPayment, importDetails.methodOfPayment) &&
        Objects.equals(this.internationalCommercialTerms, importDetails.internationalCommercialTerms) &&
        Objects.equals(this.portOfDelivery, importDetails.portOfDelivery) &&
        Objects.equals(this.importContainers, importDetails.importContainers) &&
        Objects.equals(this.shippingInstructions, importDetails.shippingInstructions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(methodOfPayment, internationalCommercialTerms, portOfDelivery, importContainers, shippingInstructions);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ImportDetails {\n");
    
    sb.append("    methodOfPayment: ").append(toIndentedString(methodOfPayment)).append("\n");
    sb.append("    internationalCommercialTerms: ").append(toIndentedString(internationalCommercialTerms)).append("\n");
    sb.append("    portOfDelivery: ").append(toIndentedString(portOfDelivery)).append("\n");
    sb.append("    importContainers: ").append(toIndentedString(importContainers)).append("\n");
    sb.append("    shippingInstructions: ").append(toIndentedString(shippingInstructions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
